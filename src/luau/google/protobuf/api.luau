--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")
local _google_protobuf_source_context = require("./source_context")
local _google_protobuf_type = require("./type")

type _ApiImpl = {
	__index: _ApiImpl,
	new: () -> Api,
	encode: (self: Api) -> buffer,
	decode: (input: buffer) -> Api,
	jsonEncode: (self: Api) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Api,
}

type _ApiFields = {
	name: string,
	methods: { Method },
	options: { _google_protobuf_type.Option },
	version: string,
	source_context: _google_protobuf_source_context.SourceContext?,
	mixins: { Mixin },
	syntax: _google_protobuf_type.Syntax,
}

export type Api = typeof(setmetatable({} :: _ApiFields, {} :: _ApiImpl))
type _MethodImpl = {
	__index: _MethodImpl,
	new: () -> Method,
	encode: (self: Method) -> buffer,
	decode: (input: buffer) -> Method,
	jsonEncode: (self: Method) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Method,
}

type _MethodFields = {
	name: string,
	request_type_url: string,
	request_streaming: boolean,
	response_type_url: string,
	response_streaming: boolean,
	options: { _google_protobuf_type.Option },
	syntax: _google_protobuf_type.Syntax,
}

export type Method = typeof(setmetatable({} :: _MethodFields, {} :: _MethodImpl))
type _MixinImpl = {
	__index: _MixinImpl,
	new: () -> Mixin,
	encode: (self: Mixin) -> buffer,
	decode: (input: buffer) -> Mixin,
	jsonEncode: (self: Mixin) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Mixin,
}

type _MixinFields = {
	name: string,
	root: string,
}

export type Mixin = typeof(setmetatable({} :: _MixinFields, {} :: _MixinImpl))

local Api: proto.Message<_ApiImpl> = {} :: _ApiImpl
Api.__index = Api

function Api.new(data: _ApiFields?): Api
	return setmetatable({
		name = data and data["name"] or "",
		methods = data and data["methods"] or {},
		options = data and data["options"] or {},
		version = data and data["version"] or "",
		source_context = data and data["source_context"] or nil,
		mixins = data and data["mixins"] or {},
		syntax = data and data["syntax"] or assert(_google_protobuf_type.Syntax.fromNumber(0), "Enum has no 0 default"),
	}, Api)
end

function Api.encode(self: Api): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.name)
	end

	if #self.methods > 0 then
		for _, value: Method in self.methods do
			local encoded = Method.encode(value)
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if #self.options > 0 then
		for _, value: _google_protobuf_type.Option in self.options do
			local encoded = _google_protobuf_type.Option.encode(value)
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if self.version ~= "" then
		output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.version)
	end

	if self.source_context ~= nil then
		local encoded = _google_protobuf_source_context.SourceContext.encode(self.source_context)
		output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
	end

	if #self.mixins > 0 then
		for _, value: Mixin in self.mixins do
			local encoded = Mixin.encode(value)
			output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if self.syntax ~= 0 or self.syntax ~= _google_protobuf_type.Syntax.fromNumber(0) then
		output, cursor = proto.writeTag(output, cursor, 7, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, _google_protobuf_type.Syntax.toNumber(self.syntax))
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Api.decode(input: buffer): Api
	local self = Api.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 7 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.syntax = _google_protobuf_type.Syntax.fromNumber(value) or value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.name = buffer.tostring(value)
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.methods, Method.decode(value))
			elseif field == 3 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.options, _google_protobuf_type.Option.decode(value))
			elseif field == 4 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.version = buffer.tostring(value)
			elseif field == 5 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.source_context = _google_protobuf_source_context.SourceContext.decode(value)
			elseif field == 6 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.mixins, Mixin.decode(value))
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Api.jsonEncode(self: Api): any
	local output: {
		name: string?,
		methods: { Method }?,
		options: { _google_protobuf_type.Option }?,
		version: string?,
		sourceContext: _google_protobuf_source_context.SourceContext?,
		mixins: { Mixin }?,
		syntax: _google_protobuf_type.Syntax?,
	} =
		{}

	if self.name ~= "" then
		output.name = self.name
	end

	if #self.methods > 0 then
		local newOutput: { Method } = {}
		for _, value: Method in self.methods do
			table.insert(newOutput, Method.jsonEncode(value))
		end
		output.methods = newOutput
	end

	if #self.options > 0 then
		local newOutput: { _google_protobuf_type.Option } = {}
		for _, value: _google_protobuf_type.Option in self.options do
			table.insert(newOutput, _google_protobuf_type.Option.jsonEncode(value))
		end
		output.options = newOutput
	end

	if self.version ~= "" then
		output.version = self.version
	end

	if self.source_context ~= nil then
		output.sourceContext = _google_protobuf_source_context.SourceContext.jsonEncode(self.source_context)
	end

	if #self.mixins > 0 then
		local newOutput: { Mixin } = {}
		for _, value: Mixin in self.mixins do
			table.insert(newOutput, Mixin.jsonEncode(value))
		end
		output.mixins = newOutput
	end

	if self.syntax ~= 0 or self.syntax ~= _google_protobuf_type.Syntax.fromNumber(0) then
		output.syntax = if typeof(self.syntax) == "number"
			then self.syntax
			else _google_protobuf_type.Syntax.toNumber(self.syntax)
	end

	return output
end

function Api.jsonDecode(input: { [string]: any }): Api
	local self = Api.new()

	if input.name ~= nil then
		self.name = input.name
	end

	if input.methods ~= nil then
		local newOutput: { Method } = {}
		for _, value: Method in input.methods do
			table.insert(newOutput, Method.jsonDecode(value))
		end

		self.methods = newOutput
	end

	if input.options ~= nil then
		local newOutput: { _google_protobuf_type.Option } = {}
		for _, value: _google_protobuf_type.Option in input.options do
			table.insert(newOutput, _google_protobuf_type.Option.jsonDecode(value))
		end

		self.options = newOutput
	end

	if input.version ~= nil then
		self.version = input.version
	end

	if input.source_context ~= nil then
		self.source_context = _google_protobuf_source_context.SourceContext.jsonDecode(input.source_context)
	end

	if input.sourceContext ~= nil then
		self.source_context = _google_protobuf_source_context.SourceContext.jsonDecode(input.sourceContext)
	end

	if input.mixins ~= nil then
		local newOutput: { Mixin } = {}
		for _, value: Mixin in input.mixins do
			table.insert(newOutput, Mixin.jsonDecode(value))
		end

		self.mixins = newOutput
	end

	if input.syntax ~= nil then
		self.syntax = if typeof(input.syntax) == "number"
			then (_google_protobuf_type.Syntax.fromNumber(input.syntax) or input.syntax)
			else (_google_protobuf_type.Syntax.fromName(input.syntax) or input.syntax)
	end

	return self
end

local Method: proto.Message<_MethodImpl> = {} :: _MethodImpl
Method.__index = Method

function Method.new(data: _MethodFields?): Method
	return setmetatable({
		name = data and data["name"] or "",
		request_type_url = data and data["request_type_url"] or "",
		request_streaming = data and data["request_streaming"] or false,
		response_type_url = data and data["response_type_url"] or "",
		response_streaming = data and data["response_streaming"] or false,
		options = data and data["options"] or {},
		syntax = data and data["syntax"] or assert(_google_protobuf_type.Syntax.fromNumber(0), "Enum has no 0 default"),
	}, Method)
end

function Method.encode(self: Method): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.name)
	end

	if self.request_type_url ~= "" then
		output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.request_type_url)
	end

	if self.request_streaming then
		output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, if self.request_streaming then 1 else 0)
	end

	if self.response_type_url ~= "" then
		output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.response_type_url)
	end

	if self.response_streaming then
		output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, if self.response_streaming then 1 else 0)
	end

	if #self.options > 0 then
		for _, value: _google_protobuf_type.Option in self.options do
			local encoded = _google_protobuf_type.Option.encode(value)
			output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if self.syntax ~= 0 or self.syntax ~= _google_protobuf_type.Syntax.fromNumber(0) then
		output, cursor = proto.writeTag(output, cursor, 7, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, _google_protobuf_type.Syntax.toNumber(self.syntax))
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Method.decode(input: buffer): Method
	local self = Method.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 3 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.request_streaming = value ~= 0
			elseif field == 5 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.response_streaming = value ~= 0
			elseif field == 7 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.syntax = _google_protobuf_type.Syntax.fromNumber(value) or value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.name = buffer.tostring(value)
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.request_type_url = buffer.tostring(value)
			elseif field == 4 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.response_type_url = buffer.tostring(value)
			elseif field == 6 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.options, _google_protobuf_type.Option.decode(value))
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Method.jsonEncode(self: Method): any
	local output: {
		name: string?,
		requestTypeUrl: string?,
		requestStreaming: boolean?,
		responseTypeUrl: string?,
		responseStreaming: boolean?,
		options: { _google_protobuf_type.Option }?,
		syntax: _google_protobuf_type.Syntax?,
	} =
		{}

	if self.name ~= "" then
		output.name = self.name
	end

	if self.request_type_url ~= "" then
		output.requestTypeUrl = self.request_type_url
	end

	if self.request_streaming then
		output.requestStreaming = self.request_streaming
	end

	if self.response_type_url ~= "" then
		output.responseTypeUrl = self.response_type_url
	end

	if self.response_streaming then
		output.responseStreaming = self.response_streaming
	end

	if #self.options > 0 then
		local newOutput: { _google_protobuf_type.Option } = {}
		for _, value: _google_protobuf_type.Option in self.options do
			table.insert(newOutput, _google_protobuf_type.Option.jsonEncode(value))
		end
		output.options = newOutput
	end

	if self.syntax ~= 0 or self.syntax ~= _google_protobuf_type.Syntax.fromNumber(0) then
		output.syntax = if typeof(self.syntax) == "number"
			then self.syntax
			else _google_protobuf_type.Syntax.toNumber(self.syntax)
	end

	return output
end

function Method.jsonDecode(input: { [string]: any }): Method
	local self = Method.new()

	if input.name ~= nil then
		self.name = input.name
	end

	if input.request_type_url ~= nil then
		self.request_type_url = input.request_type_url
	end

	if input.requestTypeUrl ~= nil then
		self.request_type_url = input.requestTypeUrl
	end

	if input.request_streaming ~= nil then
		self.request_streaming = input.request_streaming
	end

	if input.requestStreaming ~= nil then
		self.request_streaming = input.requestStreaming
	end

	if input.response_type_url ~= nil then
		self.response_type_url = input.response_type_url
	end

	if input.responseTypeUrl ~= nil then
		self.response_type_url = input.responseTypeUrl
	end

	if input.response_streaming ~= nil then
		self.response_streaming = input.response_streaming
	end

	if input.responseStreaming ~= nil then
		self.response_streaming = input.responseStreaming
	end

	if input.options ~= nil then
		local newOutput: { _google_protobuf_type.Option } = {}
		for _, value: _google_protobuf_type.Option in input.options do
			table.insert(newOutput, _google_protobuf_type.Option.jsonDecode(value))
		end

		self.options = newOutput
	end

	if input.syntax ~= nil then
		self.syntax = if typeof(input.syntax) == "number"
			then (_google_protobuf_type.Syntax.fromNumber(input.syntax) or input.syntax)
			else (_google_protobuf_type.Syntax.fromName(input.syntax) or input.syntax)
	end

	return self
end

local Mixin: proto.Message<_MixinImpl> = {} :: _MixinImpl
Mixin.__index = Mixin

function Mixin.new(data: _MixinFields?): Mixin
	return setmetatable({
		name = data and data["name"] or "",
		root = data and data["root"] or "",
	}, Mixin)
end

function Mixin.encode(self: Mixin): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.name)
	end

	if self.root ~= "" then
		output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.root)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Mixin.decode(input: buffer): Mixin
	local self = Mixin.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.name = buffer.tostring(value)
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.root = buffer.tostring(value)
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Mixin.jsonEncode(self: Mixin): any
	local output: {
		name: string?,
		root: string?,
	} = {}

	if self.name ~= "" then
		output.name = self.name
	end

	if self.root ~= "" then
		output.root = self.root
	end

	return output
end

function Mixin.jsonDecode(input: { [string]: any }): Mixin
	local self = Mixin.new()

	if input.name ~= nil then
		self.name = input.name
	end

	if input.root ~= nil then
		self.root = input.root
	end

	return self
end

return {
	Api = Api,
	Method = Method,
	Mixin = Mixin,
}
