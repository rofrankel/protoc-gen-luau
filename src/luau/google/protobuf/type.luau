--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")
local _google_protobuf_any = require("./any")
local _google_protobuf_source_context = require("./source_context")

type _TypeImpl = {
	__index: _TypeImpl,
	new: () -> Type,
	encode: (self: Type) -> buffer,
	decode: (input: buffer) -> Type,
	jsonEncode: (self: Type) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Type,
}

type _TypeFields = {
	name: string,
	fields: { Field },
	oneofs: { string },
	options: { Option },
	source_context: _google_protobuf_source_context.SourceContext?,
	syntax: Syntax,
}

export type Type = typeof(setmetatable({} :: _TypeFields, {} :: _TypeImpl))
type _FieldImpl = {
	__index: _FieldImpl,
	new: () -> Field,
	encode: (self: Field) -> buffer,
	decode: (input: buffer) -> Field,
	jsonEncode: (self: Field) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Field,
}

type _FieldFields = {
	kind: Field_Kind,
	cardinality: Field_Cardinality,
	number: number,
	name: string,
	type_url: string,
	oneof_index: number,
	packed: boolean,
	options: { Option },
	json_name: string,
	default_value: string,
}

export type Field = typeof(setmetatable({} :: _FieldFields, {} :: _FieldImpl))
local Field_Kind: proto.Enum<Field_Kind>
export type Field_Kind =
	"TYPE_UNKNOWN"
	| "TYPE_DOUBLE"
	| "TYPE_FLOAT"
	| "TYPE_INT64"
	| "TYPE_UINT64"
	| "TYPE_INT32"
	| "TYPE_FIXED64"
	| "TYPE_FIXED32"
	| "TYPE_BOOL"
	| "TYPE_STRING"
	| "TYPE_GROUP"
	| "TYPE_MESSAGE"
	| "TYPE_BYTES"
	| "TYPE_UINT32"
	| "TYPE_ENUM"
	| "TYPE_SFIXED32"
	| "TYPE_SFIXED64"
	| "TYPE_SINT32"
	| "TYPE_SINT64"
	| number -- Unknown

local Field_Cardinality: proto.Enum<Field_Cardinality>
export type Field_Cardinality =
	"CARDINALITY_UNKNOWN"
	| "CARDINALITY_OPTIONAL"
	| "CARDINALITY_REQUIRED"
	| "CARDINALITY_REPEATED"
	| number -- Unknown

type _EnumImpl = {
	__index: _EnumImpl,
	new: () -> Enum,
	encode: (self: Enum) -> buffer,
	decode: (input: buffer) -> Enum,
	jsonEncode: (self: Enum) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Enum,
}

type _EnumFields = {
	name: string,
	enumvalue: { EnumValue },
	options: { Option },
	source_context: _google_protobuf_source_context.SourceContext?,
	syntax: Syntax,
}

export type Enum = typeof(setmetatable({} :: _EnumFields, {} :: _EnumImpl))
type _EnumValueImpl = {
	__index: _EnumValueImpl,
	new: () -> EnumValue,
	encode: (self: EnumValue) -> buffer,
	decode: (input: buffer) -> EnumValue,
	jsonEncode: (self: EnumValue) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> EnumValue,
}

type _EnumValueFields = {
	name: string,
	number: number,
	options: { Option },
}

export type EnumValue = typeof(setmetatable({} :: _EnumValueFields, {} :: _EnumValueImpl))
type _OptionImpl = {
	__index: _OptionImpl,
	new: () -> Option,
	encode: (self: Option) -> buffer,
	decode: (input: buffer) -> Option,
	jsonEncode: (self: Option) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Option,
}

type _OptionFields = {
	name: string,
	value: _google_protobuf_any.Any?,
}

export type Option = typeof(setmetatable({} :: _OptionFields, {} :: _OptionImpl))
local Syntax: proto.Enum<Syntax>
export type Syntax = "SYNTAX_PROTO2" | "SYNTAX_PROTO3" | number -- Unknown

local Type: proto.Message<_TypeImpl> = {} :: _TypeImpl
Type.__index = Type

function Type.new(data: _TypeFields?): Type
	return setmetatable({
		name = data and data["name"] or "",
		fields = data and data["fields"] or {},
		oneofs = data and data["oneofs"] or {},
		options = data and data["options"] or {},
		source_context = data and data["source_context"] or nil,
		syntax = data and data["syntax"] or assert(Syntax.fromNumber(0), "Enum has no 0 default"),
	}, Type)
end

function Type.encode(self: Type): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.name)
	end

	if #self.fields > 0 then
		for _, value: Field in self.fields do
			local encoded = Field.encode(value)
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if #self.oneofs > 0 then
		for _, value: string in self.oneofs do
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, value)
		end
	end

	if #self.options > 0 then
		for _, value: Option in self.options do
			local encoded = Option.encode(value)
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if self.source_context ~= nil then
		local encoded = _google_protobuf_source_context.SourceContext.encode(self.source_context)
		output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
	end

	if self.syntax ~= 0 or self.syntax ~= Syntax.fromNumber(0) then
		output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, Syntax.toNumber(self.syntax))
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Type.decode(input: buffer): Type
	local self = Type.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 6 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.syntax = Syntax.fromNumber(value) or value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.name = buffer.tostring(value)
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.fields, Field.decode(value))
			elseif field == 3 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.oneofs, buffer.tostring(value))
			elseif field == 4 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.options, Option.decode(value))
			elseif field == 5 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.source_context = _google_protobuf_source_context.SourceContext.decode(value)
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Type.jsonEncode(self: Type): any
	local output: {
		name: string?,
		fields: { Field }?,
		oneofs: { string }?,
		options: { Option }?,
		sourceContext: _google_protobuf_source_context.SourceContext?,
		syntax: Syntax?,
	} =
		{}

	if self.name ~= "" then
		output.name = self.name
	end

	if #self.fields > 0 then
		local newOutput: { Field } = {}
		for _, value: Field in self.fields do
			table.insert(newOutput, Field.jsonEncode(value))
		end
		output.fields = newOutput
	end

	if #self.oneofs > 0 then
		local newOutput: { string } = {}
		for _, value: string in self.oneofs do
			table.insert(newOutput, value)
		end
		output.oneofs = newOutput
	end

	if #self.options > 0 then
		local newOutput: { Option } = {}
		for _, value: Option in self.options do
			table.insert(newOutput, Option.jsonEncode(value))
		end
		output.options = newOutput
	end

	if self.source_context ~= nil then
		output.sourceContext = _google_protobuf_source_context.SourceContext.jsonEncode(self.source_context)
	end

	if self.syntax ~= 0 or self.syntax ~= Syntax.fromNumber(0) then
		output.syntax = if typeof(self.syntax) == "number" then self.syntax else Syntax.toNumber(self.syntax)
	end

	return output
end

function Type.jsonDecode(input: { [string]: any }): Type
	local self = Type.new()

	if input.name ~= nil then
		self.name = input.name
	end

	if input.fields ~= nil then
		local newOutput: { Field } = {}
		for _, value: Field in input.fields do
			table.insert(newOutput, Field.jsonDecode(value))
		end

		self.fields = newOutput
	end

	if input.oneofs ~= nil then
		local newOutput: { string } = {}
		for _, value: string in input.oneofs do
			table.insert(newOutput, value)
		end

		self.oneofs = newOutput
	end

	if input.options ~= nil then
		local newOutput: { Option } = {}
		for _, value: Option in input.options do
			table.insert(newOutput, Option.jsonDecode(value))
		end

		self.options = newOutput
	end

	if input.source_context ~= nil then
		self.source_context = _google_protobuf_source_context.SourceContext.jsonDecode(input.source_context)
	end

	if input.sourceContext ~= nil then
		self.source_context = _google_protobuf_source_context.SourceContext.jsonDecode(input.sourceContext)
	end

	if input.syntax ~= nil then
		self.syntax = if typeof(input.syntax) == "number"
			then (Syntax.fromNumber(input.syntax) or input.syntax)
			else (Syntax.fromName(input.syntax) or input.syntax)
	end

	return self
end

local Field: proto.Message<_FieldImpl> = {} :: _FieldImpl
Field.__index = Field

function Field.new(data: _FieldFields?): Field
	return setmetatable({
		kind = data and data["kind"] or assert(Field_Kind.fromNumber(0), "Enum has no 0 default"),
		cardinality = data and data["cardinality"] or assert(Field_Cardinality.fromNumber(0), "Enum has no 0 default"),
		number = data and data["number"] or 0,
		name = data and data["name"] or "",
		type_url = data and data["type_url"] or "",
		oneof_index = data and data["oneof_index"] or 0,
		packed = data and data["packed"] or false,
		options = data and data["options"] or {},
		json_name = data and data["json_name"] or "",
		default_value = data and data["default_value"] or "",
	}, Field)
end

function Field.encode(self: Field): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.kind ~= 0 or self.kind ~= Field_Kind.fromNumber(0) then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, Field_Kind.toNumber(self.kind))
	end

	if self.cardinality ~= 0 or self.cardinality ~= Field_Cardinality.fromNumber(0) then
		output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, Field_Cardinality.toNumber(self.cardinality))
	end

	if self.number ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.number)
	end

	if self.name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.name)
	end

	if self.type_url ~= "" then
		output, cursor = proto.writeTag(output, cursor, 6, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.type_url)
	end

	if self.oneof_index ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 7, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.oneof_index)
	end

	if self.packed then
		output, cursor = proto.writeTag(output, cursor, 8, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, if self.packed then 1 else 0)
	end

	if #self.options > 0 then
		for _, value: Option in self.options do
			local encoded = Option.encode(value)
			output, cursor = proto.writeTag(output, cursor, 9, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if self.json_name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 10, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.json_name)
	end

	if self.default_value ~= "" then
		output, cursor = proto.writeTag(output, cursor, 11, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.default_value)
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Field.decode(input: buffer): Field
	local self = Field.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 1 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.kind = Field_Kind.fromNumber(value) or value
			elseif field == 2 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.cardinality = Field_Cardinality.fromNumber(value) or value
			elseif field == 3 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.number = proto.limitInt32(value)
			elseif field == 7 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.oneof_index = proto.limitInt32(value)
			elseif field == 8 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.packed = value ~= 0
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 4 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.name = buffer.tostring(value)
			elseif field == 6 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.type_url = buffer.tostring(value)
			elseif field == 9 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.options, Option.decode(value))
			elseif field == 10 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.json_name = buffer.tostring(value)
			elseif field == 11 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.default_value = buffer.tostring(value)
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Field.jsonEncode(self: Field): any
	local output: {
		kind: Field_Kind?,
		cardinality: Field_Cardinality?,
		number: number?,
		name: string?,
		typeUrl: string?,
		oneofIndex: number?,
		packed: boolean?,
		options: { Option }?,
		jsonName: string?,
		defaultValue: string?,
	} =
		{}

	if self.kind ~= 0 or self.kind ~= Field_Kind.fromNumber(0) then
		output.kind = if typeof(self.kind) == "number" then self.kind else Field_Kind.toNumber(self.kind)
	end

	if self.cardinality ~= 0 or self.cardinality ~= Field_Cardinality.fromNumber(0) then
		output.cardinality = if typeof(self.cardinality) == "number"
			then self.cardinality
			else Field_Cardinality.toNumber(self.cardinality)
	end

	if self.number ~= 0 then
		output.number = self.number
	end

	if self.name ~= "" then
		output.name = self.name
	end

	if self.type_url ~= "" then
		output.typeUrl = self.type_url
	end

	if self.oneof_index ~= 0 then
		output.oneofIndex = self.oneof_index
	end

	if self.packed then
		output.packed = self.packed
	end

	if #self.options > 0 then
		local newOutput: { Option } = {}
		for _, value: Option in self.options do
			table.insert(newOutput, Option.jsonEncode(value))
		end
		output.options = newOutput
	end

	if self.json_name ~= "" then
		output.jsonName = self.json_name
	end

	if self.default_value ~= "" then
		output.defaultValue = self.default_value
	end

	return output
end

function Field.jsonDecode(input: { [string]: any }): Field
	local self = Field.new()

	if input.kind ~= nil then
		self.kind = if typeof(input.kind) == "number"
			then (Field_Kind.fromNumber(input.kind) or input.kind)
			else (Field_Kind.fromName(input.kind) or input.kind)
	end

	if input.cardinality ~= nil then
		self.cardinality = if typeof(input.cardinality) == "number"
			then (Field_Cardinality.fromNumber(input.cardinality) or input.cardinality)
			else (Field_Cardinality.fromName(input.cardinality) or input.cardinality)
	end

	if input.number ~= nil then
		self.number = input.number
	end

	if input.name ~= nil then
		self.name = input.name
	end

	if input.type_url ~= nil then
		self.type_url = input.type_url
	end

	if input.typeUrl ~= nil then
		self.type_url = input.typeUrl
	end

	if input.oneof_index ~= nil then
		self.oneof_index = input.oneof_index
	end

	if input.oneofIndex ~= nil then
		self.oneof_index = input.oneofIndex
	end

	if input.packed ~= nil then
		self.packed = input.packed
	end

	if input.options ~= nil then
		local newOutput: { Option } = {}
		for _, value: Option in input.options do
			table.insert(newOutput, Option.jsonDecode(value))
		end

		self.options = newOutput
	end

	if input.json_name ~= nil then
		self.json_name = input.json_name
	end

	if input.jsonName ~= nil then
		self.json_name = input.jsonName
	end

	if input.default_value ~= nil then
		self.default_value = input.default_value
	end

	if input.defaultValue ~= nil then
		self.default_value = input.defaultValue
	end

	return self
end

Field_Kind = {
	fromNumber = function(value: number): Field_Kind?
		if value == 0 then
			return "TYPE_UNKNOWN"
		elseif value == 1 then
			return "TYPE_DOUBLE"
		elseif value == 2 then
			return "TYPE_FLOAT"
		elseif value == 3 then
			return "TYPE_INT64"
		elseif value == 4 then
			return "TYPE_UINT64"
		elseif value == 5 then
			return "TYPE_INT32"
		elseif value == 6 then
			return "TYPE_FIXED64"
		elseif value == 7 then
			return "TYPE_FIXED32"
		elseif value == 8 then
			return "TYPE_BOOL"
		elseif value == 9 then
			return "TYPE_STRING"
		elseif value == 10 then
			return "TYPE_GROUP"
		elseif value == 11 then
			return "TYPE_MESSAGE"
		elseif value == 12 then
			return "TYPE_BYTES"
		elseif value == 13 then
			return "TYPE_UINT32"
		elseif value == 14 then
			return "TYPE_ENUM"
		elseif value == 15 then
			return "TYPE_SFIXED32"
		elseif value == 16 then
			return "TYPE_SFIXED64"
		elseif value == 17 then
			return "TYPE_SINT32"
		elseif value == 18 then
			return "TYPE_SINT64"
		else
			return nil
		end
	end,

	toNumber = function(self: Field_Kind): number
		if self == "TYPE_UNKNOWN" then
			return 0
		elseif self == "TYPE_DOUBLE" then
			return 1
		elseif self == "TYPE_FLOAT" then
			return 2
		elseif self == "TYPE_INT64" then
			return 3
		elseif self == "TYPE_UINT64" then
			return 4
		elseif self == "TYPE_INT32" then
			return 5
		elseif self == "TYPE_FIXED64" then
			return 6
		elseif self == "TYPE_FIXED32" then
			return 7
		elseif self == "TYPE_BOOL" then
			return 8
		elseif self == "TYPE_STRING" then
			return 9
		elseif self == "TYPE_GROUP" then
			return 10
		elseif self == "TYPE_MESSAGE" then
			return 11
		elseif self == "TYPE_BYTES" then
			return 12
		elseif self == "TYPE_UINT32" then
			return 13
		elseif self == "TYPE_ENUM" then
			return 14
		elseif self == "TYPE_SFIXED32" then
			return 15
		elseif self == "TYPE_SFIXED64" then
			return 16
		elseif self == "TYPE_SINT32" then
			return 17
		elseif self == "TYPE_SINT64" then
			return 18
		else
			return self
		end
	end,

	fromName = function(name: string): Field_Kind?
		if name == "TYPE_UNKNOWN" then
			return "TYPE_UNKNOWN"
		elseif name == "TYPE_DOUBLE" then
			return "TYPE_DOUBLE"
		elseif name == "TYPE_FLOAT" then
			return "TYPE_FLOAT"
		elseif name == "TYPE_INT64" then
			return "TYPE_INT64"
		elseif name == "TYPE_UINT64" then
			return "TYPE_UINT64"
		elseif name == "TYPE_INT32" then
			return "TYPE_INT32"
		elseif name == "TYPE_FIXED64" then
			return "TYPE_FIXED64"
		elseif name == "TYPE_FIXED32" then
			return "TYPE_FIXED32"
		elseif name == "TYPE_BOOL" then
			return "TYPE_BOOL"
		elseif name == "TYPE_STRING" then
			return "TYPE_STRING"
		elseif name == "TYPE_GROUP" then
			return "TYPE_GROUP"
		elseif name == "TYPE_MESSAGE" then
			return "TYPE_MESSAGE"
		elseif name == "TYPE_BYTES" then
			return "TYPE_BYTES"
		elseif name == "TYPE_UINT32" then
			return "TYPE_UINT32"
		elseif name == "TYPE_ENUM" then
			return "TYPE_ENUM"
		elseif name == "TYPE_SFIXED32" then
			return "TYPE_SFIXED32"
		elseif name == "TYPE_SFIXED64" then
			return "TYPE_SFIXED64"
		elseif name == "TYPE_SINT32" then
			return "TYPE_SINT32"
		elseif name == "TYPE_SINT64" then
			return "TYPE_SINT64"
		else
			return nil
		end
	end,
}

Field_Cardinality = {
	fromNumber = function(value: number): Field_Cardinality?
		if value == 0 then
			return "CARDINALITY_UNKNOWN"
		elseif value == 1 then
			return "CARDINALITY_OPTIONAL"
		elseif value == 2 then
			return "CARDINALITY_REQUIRED"
		elseif value == 3 then
			return "CARDINALITY_REPEATED"
		else
			return nil
		end
	end,

	toNumber = function(self: Field_Cardinality): number
		if self == "CARDINALITY_UNKNOWN" then
			return 0
		elseif self == "CARDINALITY_OPTIONAL" then
			return 1
		elseif self == "CARDINALITY_REQUIRED" then
			return 2
		elseif self == "CARDINALITY_REPEATED" then
			return 3
		else
			return self
		end
	end,

	fromName = function(name: string): Field_Cardinality?
		if name == "CARDINALITY_UNKNOWN" then
			return "CARDINALITY_UNKNOWN"
		elseif name == "CARDINALITY_OPTIONAL" then
			return "CARDINALITY_OPTIONAL"
		elseif name == "CARDINALITY_REQUIRED" then
			return "CARDINALITY_REQUIRED"
		elseif name == "CARDINALITY_REPEATED" then
			return "CARDINALITY_REPEATED"
		else
			return nil
		end
	end,
}

local Enum: proto.Message<_EnumImpl> = {} :: _EnumImpl
Enum.__index = Enum

function Enum.new(data: _EnumFields?): Enum
	return setmetatable({
		name = data and data["name"] or "",
		enumvalue = data and data["enumvalue"] or {},
		options = data and data["options"] or {},
		source_context = data and data["source_context"] or nil,
		syntax = data and data["syntax"] or assert(Syntax.fromNumber(0), "Enum has no 0 default"),
	}, Enum)
end

function Enum.encode(self: Enum): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.name)
	end

	if #self.enumvalue > 0 then
		for _, value: EnumValue in self.enumvalue do
			local encoded = EnumValue.encode(value)
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if #self.options > 0 then
		for _, value: Option in self.options do
			local encoded = Option.encode(value)
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	if self.source_context ~= nil then
		local encoded = _google_protobuf_source_context.SourceContext.encode(self.source_context)
		output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
	end

	if self.syntax ~= 0 or self.syntax ~= Syntax.fromNumber(0) then
		output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, Syntax.toNumber(self.syntax))
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Enum.decode(input: buffer): Enum
	local self = Enum.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 5 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.syntax = Syntax.fromNumber(value) or value
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.name = buffer.tostring(value)
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.enumvalue, EnumValue.decode(value))
			elseif field == 3 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.options, Option.decode(value))
			elseif field == 4 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.source_context = _google_protobuf_source_context.SourceContext.decode(value)
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Enum.jsonEncode(self: Enum): any
	local output: {
		name: string?,
		enumvalue: { EnumValue }?,
		options: { Option }?,
		sourceContext: _google_protobuf_source_context.SourceContext?,
		syntax: Syntax?,
	} =
		{}

	if self.name ~= "" then
		output.name = self.name
	end

	if #self.enumvalue > 0 then
		local newOutput: { EnumValue } = {}
		for _, value: EnumValue in self.enumvalue do
			table.insert(newOutput, EnumValue.jsonEncode(value))
		end
		output.enumvalue = newOutput
	end

	if #self.options > 0 then
		local newOutput: { Option } = {}
		for _, value: Option in self.options do
			table.insert(newOutput, Option.jsonEncode(value))
		end
		output.options = newOutput
	end

	if self.source_context ~= nil then
		output.sourceContext = _google_protobuf_source_context.SourceContext.jsonEncode(self.source_context)
	end

	if self.syntax ~= 0 or self.syntax ~= Syntax.fromNumber(0) then
		output.syntax = if typeof(self.syntax) == "number" then self.syntax else Syntax.toNumber(self.syntax)
	end

	return output
end

function Enum.jsonDecode(input: { [string]: any }): Enum
	local self = Enum.new()

	if input.name ~= nil then
		self.name = input.name
	end

	if input.enumvalue ~= nil then
		local newOutput: { EnumValue } = {}
		for _, value: EnumValue in input.enumvalue do
			table.insert(newOutput, EnumValue.jsonDecode(value))
		end

		self.enumvalue = newOutput
	end

	if input.options ~= nil then
		local newOutput: { Option } = {}
		for _, value: Option in input.options do
			table.insert(newOutput, Option.jsonDecode(value))
		end

		self.options = newOutput
	end

	if input.source_context ~= nil then
		self.source_context = _google_protobuf_source_context.SourceContext.jsonDecode(input.source_context)
	end

	if input.sourceContext ~= nil then
		self.source_context = _google_protobuf_source_context.SourceContext.jsonDecode(input.sourceContext)
	end

	if input.syntax ~= nil then
		self.syntax = if typeof(input.syntax) == "number"
			then (Syntax.fromNumber(input.syntax) or input.syntax)
			else (Syntax.fromName(input.syntax) or input.syntax)
	end

	return self
end

local EnumValue: proto.Message<_EnumValueImpl> = {} :: _EnumValueImpl
EnumValue.__index = EnumValue

function EnumValue.new(data: _EnumValueFields?): EnumValue
	return setmetatable({
		name = data and data["name"] or "",
		number = data and data["number"] or 0,
		options = data and data["options"] or {},
	}, EnumValue)
end

function EnumValue.encode(self: EnumValue): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.name)
	end

	if self.number ~= 0 then
		output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
		output, cursor = proto.writeVarInt(output, cursor, self.number)
	end

	if #self.options > 0 then
		for _, value: Option in self.options do
			local encoded = Option.encode(value)
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function EnumValue.decode(input: buffer): EnumValue
	local self = EnumValue.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			if field == 2 then
				local value
				value, cursor = proto.readVarInt(input, cursor)
				self.number = proto.limitInt32(value)
			end
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.name = buffer.tostring(value)
			elseif field == 3 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				table.insert(self.options, Option.decode(value))
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function EnumValue.jsonEncode(self: EnumValue): any
	local output: {
		name: string?,
		number: number?,
		options: { Option }?,
	} = {}

	if self.name ~= "" then
		output.name = self.name
	end

	if self.number ~= 0 then
		output.number = self.number
	end

	if #self.options > 0 then
		local newOutput: { Option } = {}
		for _, value: Option in self.options do
			table.insert(newOutput, Option.jsonEncode(value))
		end
		output.options = newOutput
	end

	return output
end

function EnumValue.jsonDecode(input: { [string]: any }): EnumValue
	local self = EnumValue.new()

	if input.name ~= nil then
		self.name = input.name
	end

	if input.number ~= nil then
		self.number = input.number
	end

	if input.options ~= nil then
		local newOutput: { Option } = {}
		for _, value: Option in input.options do
			table.insert(newOutput, Option.jsonDecode(value))
		end

		self.options = newOutput
	end

	return self
end

local Option: proto.Message<_OptionImpl> = {} :: _OptionImpl
Option.__index = Option

function Option.new(data: _OptionFields?): Option
	return setmetatable({
		name = data and data["name"] or "",
		value = data and data["value"] or nil,
	}, Option)
end

function Option.encode(self: Option): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.name ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.name)
	end

	if self.value ~= nil then
		local encoded = _google_protobuf_any.Any.encode(self.value)
		output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Option.decode(input: buffer): Option
	local self = Option.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.name = buffer.tostring(value)
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.value = _google_protobuf_any.Any.decode(value)
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Option.jsonEncode(self: Option): any
	local output: {
		name: string?,
		value: _google_protobuf_any.Any?,
	} = {}

	if self.name ~= "" then
		output.name = self.name
	end

	if self.value ~= nil then
		output.value = _google_protobuf_any.Any.jsonEncode(self.value)
	end

	return output
end

function Option.jsonDecode(input: { [string]: any }): Option
	local self = Option.new()

	if input.name ~= nil then
		self.name = input.name
	end

	if input.value ~= nil then
		self.value = _google_protobuf_any.Any.jsonDecode(input.value)
	end

	return self
end

Syntax = {
	fromNumber = function(value: number): Syntax?
		if value == 0 then
			return "SYNTAX_PROTO2"
		elseif value == 1 then
			return "SYNTAX_PROTO3"
		else
			return nil
		end
	end,

	toNumber = function(self: Syntax): number
		if self == "SYNTAX_PROTO2" then
			return 0
		elseif self == "SYNTAX_PROTO3" then
			return 1
		else
			return self
		end
	end,

	fromName = function(name: string): Syntax?
		if name == "SYNTAX_PROTO2" then
			return "SYNTAX_PROTO2"
		elseif name == "SYNTAX_PROTO3" then
			return "SYNTAX_PROTO3"
		else
			return nil
		end
	end,
}

return {
	Type = Type,
	Field = Field,
	Field_Kind = Field_Kind,
	Field_Cardinality = Field_Cardinality,
	Enum = Enum,
	EnumValue = EnumValue,
	Option = Option,
	Syntax = Syntax,
}
