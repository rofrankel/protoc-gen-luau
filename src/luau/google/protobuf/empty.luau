--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")

type _EmptyImpl = {
	__index: _EmptyImpl,
	new: () -> Empty,
	encode: (self: Empty) -> buffer,
	decode: (input: buffer) -> Empty,
	jsonEncode: (self: Empty) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Empty,
}

type _EmptyFields = {}

export type Empty = typeof(setmetatable({} :: _EmptyFields, {} :: _EmptyImpl))

local Empty: proto.Message<_EmptyImpl> = {} :: _EmptyImpl
Empty.__index = Empty

function Empty.new(data: _EmptyFields?): Empty
	return setmetatable({}, Empty)
end

function Empty.encode(self: Empty): buffer
	local output = buffer.create(0)
	local cursor = 0

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Empty.decode(input: buffer): Empty
	local self = Empty.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			-- No fields
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Empty.jsonEncode(self: Empty): any
	local output: {} = {}

	return output
end

function Empty.jsonDecode(input: { [string]: any }): Empty
	local self = Empty.new()

	return self
end

return {
	Empty = Empty,
}
