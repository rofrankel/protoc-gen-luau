--!strict
--!nolint LocalUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require("../../proto")
local wktJson = require("../../proto/wktJson")
local descriptor = require("../../proto/descriptor")
local typeRegistry = require("../../proto/typeRegistry")

type _AnyImpl = {
	__index: _AnyImpl,
	new: () -> Any,
	encode: (self: Any) -> string,
	decode: (input: buffer) -> Any,
	jsonEncode: (self: Any, options: proto.JsonEncodingOptions?) -> any,
	jsonDecode: (input: { [string]: any }, options: proto.JsonDecodingOptions?) -> Any,
	descriptor: () -> descriptor.Descriptor,
}

type _AnyFields = {
	type_url: string,
	value: buffer,

	-- Pack a message into the Any.
	--
	-- If typePrefix is not provided, defaults to "apis.roblox.com/cloud".
	pack: (self: Any, payload: Message, typePrefix: string?) -> (),

	-- Returns the message contained by the Any (or nil if the Any is empty).
	unpack: (self: Any) -> Message?,

	-- Returns true iff the Any contains an object of the type specified by
	-- typeName. If typeName is a full type URL, it will be compared; otherwise,
	-- only the type name will be compared.
	isA: (self: Any, typeName: string) -> boolean,
}

export type Any = typeof(setmetatable({} :: _AnyFields, {} :: _AnyImpl))

local Any: proto.Message<_AnyImpl> = {} :: _AnyImpl
Any.__index = Any

function Any.new(data: _AnyFields?): Any
	return setmetatable({
		type_url = data and data["type_url"] or "",
		value = data and data["value"] or buffer.create(0),
	}, Any)
end

function Any.encode(self: Any): buffer
	local output = buffer.create(0)
	local cursor = 0

	if self.type_url ~= "" then
		output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeString(output, cursor, self.type_url)
	end

	if buffer.len(self.value) > 0 then
		output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
		output, cursor = proto.writeBuffer(output, cursor, self.value, buffer.len(self.value))
	end

	local shrunkBuffer = buffer.create(cursor)
	buffer.copy(shrunkBuffer, 0, output, 0, cursor)
	return shrunkBuffer
end

function Any.decode(input: buffer): Any
	local self = Any.new()
	local cursor = 0

	while cursor < buffer.len(input) do
		local field, wireType
		field, wireType, cursor = proto.readTag(input, cursor)

		if wireType == proto.wireTypes.varint then
			-- No fields
		elseif wireType == proto.wireTypes.lengthDelimited then
			if field == 1 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.type_url = buffer.tostring(value)
			elseif field == 2 then
				local value
				value, cursor = proto.readBuffer(input, cursor)
				self.value = value
			end
		elseif wireType == proto.wireTypes.i32 then
			-- No fields
		elseif wireType == proto.wireTypes.i64 then
			-- No fields
		else
			error("Unsupported wire type: " .. wireType)
		end
	end

	return self
end

function Any.jsonEncode(self: Any, options: proto.JsonEncodingOptions?): any
	return wktJson.Any.serialize(self :: any, options)
end

function Any.jsonDecode(input: { [string]: any }, options: proto.JsonDecodingOptions?): Any
	return wktJson.Any.deserialize(input :: any, Any.new, options) -- any cast because we have a special jsonDecode
end

function Any.pack(self: Any, payload: Message, typePrefix: string?): ()
	self.type_url = typePrefix or "apis.roblox.com/cloud" .. "/" .. payload.descriptor().full_name()
	self.value = payload:encode()
end

function Any.unpack(self: Any, registry: typeRegistry.TypeRegistry): Message?
	if self.value == nil then
		return nil
	end

	local typeName = self.typeUrlToTypeName(self.type_url)
	local payloadType = registry:findMessage(typeName)

	if payloadType == nil then
		error("Unknown type: " .. typeName)
	end

	return payloadType.decode(self.value)
end

function Any.isA(self: Any, typeName: string): boolean
	if self.type_url == typeName then
		return true
	end

	local suffix = "/" .. typeName
	return self.type_url:sub(-#suffix) == suffix
end

function Any.typeUrlToTypeName(typeUrl: string): string
	local first, _ = typeUrl:find("([^/]+)$")
	return typeUrl:sub(first)
end

function Any.descriptor(): descriptor.Descriptor
	local descriptor = descriptor.Descriptor.new()
	descriptor.name = function()
		return "Any"
	end
	descriptor.full_name = function()
		return "google.protobuf.Any"
	end
	return descriptor
end

return {
	Any = Any,
}
